# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:27:08+00:00



import argparse
import json
import os
from datetime import datetime
from pathlib import Path
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBasic,
    UnsuportedSecurityStub,
)
from pydantic import conint

from models import (
    DAG,
    ActionCollection,
    ClearDagRun,
    ClearTaskInstances,
    Config,
    Connection,
    ConnectionCollection,
    ConnectionTest,
    DAGCollection,
    DAGDetail,
    DAGRun,
    DAGRunCollection,
    DagsDagIdDagRunsDagRunIdTaskInstancesTaskIdLogsTaskTryNumberGetResponse,
    DagSourcesFileTokenGetResponse,
    DagWarningCollection,
    Dataset,
    DatasetCollection,
    DatasetEventCollection,
    Error,
    EventLog,
    EventLogCollection,
    ExtraLinkCollection,
    HealthInfo,
    ImportError,
    ImportErrorCollection,
    ListDagRunsForm,
    ListTaskInstanceForm,
    PluginCollection,
    Pool,
    Pool1,
    PoolCollection,
    ProvidersGetResponse,
    Queue,
    Role,
    RoleCollection,
    SetDagRunNote,
    SetTaskInstanceNote,
    State1,
    Tags,
    Task,
    TaskCollection,
    TaskInstance,
    TaskInstanceCollection,
    TaskInstanceReference,
    TaskInstanceReferenceCollection,
    UpdateDagRunState,
    UpdateMask,
    UpdateTaskInstance,
    UpdateTaskInstancesState,
    User,
    UserCollection,
    UserCollectionItem,
    Variable,
    VariableCollection,
    VersionInfo,
    XCom,
    XComCollection,
)

app = MCPProxy(
    contact={
        'email': 'dev@airflow.apache.org',
        'name': 'Apache Software Foundation',
        'url': 'https://airflow.apache.org',
        'x-twitter': 'TheASF',
    },
    description='# Overview\n\nTo facilitate management, Apache Airflow supports a range of REST API endpoints across its\nobjects.\nThis section provides an overview of the API design, methods, and supported use cases.\n\nMost of the endpoints accept `JSON` as input and return `JSON` responses.\nThis means that you must usually add the following headers to your request:\n```\nContent-type: application/json\nAccept: application/json\n```\n\n## Resources\n\nThe term `resource` refers to a single type of object in the Airflow metadata. An API is broken up by its\nendpoint\'s corresponding resource.\nThe name of a resource is typically plural and expressed in camelCase. Example: `dagRuns`.\n\nResource names are used as part of endpoint URLs, as well as in API parameters and responses.\n\n## CRUD Operations\n\nThe platform supports **C**reate, **R**ead, **U**pdate, and **D**elete operations on most resources.\nYou can review the standards for these operations and their standard parameters below.\n\nSome endpoints have special behavior as exceptions.\n\n### Create\n\nTo create a resource, you typically submit an HTTP `POST` request with the resource\'s required metadata\nin the request body.\nThe response returns a `201 Created` response code upon success with the resource\'s metadata, including\nits internal `id`, in the response body.\n\n### Read\n\nThe HTTP `GET` request can be used to read a resource or to list a number of resources.\n\nA resource\'s `id` can be submitted in the request parameters to read a specific resource.\nThe response usually returns a `200 OK` response code upon success, with the resource\'s metadata in\nthe response body.\n\nIf a `GET` request does not include a specific resource `id`, it is treated as a list request.\nThe response usually returns a `200 OK` response code upon success, with an object containing a list\nof resources\' metadata in the response body.\n\nWhen reading resources, some common query parameters are usually available. e.g.:\n```\nv1/connections?limit=25&offset=25\n```\n\n|Query Parameter|Type|Description|\n|---------------|----|-----------|\n|limit|integer|Maximum number of objects to fetch. Usually 25 by default|\n|offset|integer|Offset after which to start returning objects. For use with limit query parameter.|\n\n### Update\n\nUpdating a resource requires the resource `id`, and is typically done using an HTTP `PATCH` request,\nwith the fields to modify in the request body.\nThe response usually returns a `200 OK` response code upon success, with information about the modified\nresource in the response body.\n\n### Delete\n\nDeleting a resource requires the resource `id` and is typically executing via an HTTP `DELETE` request.\nThe response usually returns a `204 No Content` response code upon success.\n\n## Conventions\n\n- Resource names are plural and expressed in camelCase.\n- Names are consistent between URL parameter name and field name.\n\n- Field names are in snake_case.\n```json\n{\n    "name": "string",\n    "slots": 0,\n    "occupied_slots": 0,\n    "used_slots": 0,\n    "queued_slots": 0,\n    "open_slots": 0\n}\n```\n\n### Update Mask\n\nUpdate mask is available as a query parameter in patch endpoints. It is used to notify the\nAPI which fields you want to update. Using `update_mask` makes it easier to update objects\nby helping the server know which fields to update in an object instead of updating all fields.\nThe update request ignores any fields that aren\'t specified in the field mask, leaving them with\ntheir current values.\n\nExample:\n```\n  resource = request.get(\'/resource/my-id\').json()\n  resource[\'my_field\'] = \'new-value\'\n  request.patch(\'/resource/my-id?update_mask=my_field\', data=json.dumps(resource))\n```\n\n## Versioning and Endpoint Lifecycle\n\n- API versioning is not synchronized to specific releases of the Apache Airflow.\n- APIs are designed to be backward compatible.\n- Any changes to the API will first go through a deprecation phase.\n\n# Trying the API\n\nYou can use a third party client, such as [curl](https://curl.haxx.se/), [HTTPie](https://httpie.org/),\n[Postman](https://www.postman.com/) or [the Insomnia rest client](https://insomnia.rest/) to test\nthe Apache Airflow API.\n\nNote that you will need to pass credentials data.\n\nFor e.g., here is how to pause a DAG with [curl](https://curl.haxx.se/), when basic authorization is used:\n```bash\ncurl -X PATCH \'https://example.com/api/v1/dags/{dag_id}?update_mask=is_paused\' \\\n-H \'Content-Type: application/json\' \\\n--user "username:password" \\\n-d \'{\n    "is_paused": true\n}\'\n```\n\nUsing a graphical tool such as [Postman](https://www.postman.com/) or [Insomnia](https://insomnia.rest/),\nit is possible to import the API specifications directly:\n\n1. Download the API specification by clicking the **Download** button at top of this document\n2. Import the JSON specification in the graphical tool of your choice.\n  - In *Postman*, you can click the **import** button at the top\n  - With *Insomnia*, you can just drag-and-drop the file on the UI\n\nNote that with *Postman*, you can also generate code snippets by selecting a request and clicking on\nthe **Code** button.\n\n## Enabling CORS\n\n[Cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\nis a browser security feature that restricts HTTP requests that are\ninitiated from scripts running in the browser.\n\nFor details on enabling/configuring CORS, see\n[Enabling CORS](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html).\n\n# Authentication\n\nTo be able to meet the requirements of many organizations, Airflow supports many authentication methods,\nand it is even possible to add your own method.\n\nIf you want to check which auth backend is currently set, you can use\n`airflow config get-value api auth_backends` command as in the example below.\n```bash\n$ airflow config get-value api auth_backends\nairflow.api.auth.backend.basic_auth\n```\nThe default is to deny all requests.\n\nFor details on configuring the authentication, see\n[API Authorization](https://airflow.apache.org/docs/apache-airflow/stable/security/api.html).\n\n# Errors\n\nWe follow the error response format proposed in [RFC 7807](https://tools.ietf.org/html/rfc7807)\nalso known as Problem Details for HTTP APIs. As with our normal API responses,\nyour client must be prepared to gracefully handle additional members of the response.\n\n## Unauthenticated\n\nThis indicates that the request has not been applied because it lacks valid authentication\ncredentials for the target resource. Please check that you have valid credentials.\n\n## PermissionDenied\n\nThis response means that the server understood the request but refuses to authorize\nit because it lacks sufficient rights to the resource. It happens when you do not have the\nnecessary permission to execute the action you performed. You need to get the appropriate\npermissions in other to resolve this error.\n\n## BadRequest\n\nThis response means that the server cannot or will not process the request due to something\nthat is perceived to be a client error (e.g., malformed request syntax, invalid request message\nframing, or deceptive request routing). To resolve this, please ensure that your syntax is correct.\n\n## NotFound\n\nThis client error response indicates that the server cannot find the requested resource.\n\n## MethodNotAllowed\n\nIndicates that the request method is known by the server but is not supported by the target resource.\n\n## NotAcceptable\n\nThe target resource does not have a current representation that would be acceptable to the user\nagent, according to the proactive negotiation header fields received in the request, and the\nserver is unwilling to supply a default representation.\n\n## AlreadyExists\n\nThe request could not be completed due to a conflict with the current state of the target\nresource, e.g. the resource it tries to create already exists.\n\n## Unknown\n\nThis means that the server encountered an unexpected condition that prevented it from\nfulfilling the request.\n',
    license={
        'name': 'Apache 2.0',
        'url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
    },
    title='Airflow API (Stable)',
    version='2.5.1',
    servers=[
        {'description': 'Apache Airflow Stable API.', 'url': '/api/v1'},
        {'url': 'https://apache.local'},
    ],
)


@app.get('/config', tags=['dag_operations', 'version_management'])
def get_config():
    """
    Get current configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/connections', tags=['connection_management'])
def get_connections(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/connections', tags=['connection_management'])
def post_connection(body: Connection):
    """
    Create a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/connections/test',
    description=""" Test a connection.

*New in version 2.2.0*
 """,
    tags=['connection_management'],
)
def test_connection(body: Connection):
    """
    Test a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/connections/{connection_id}', tags=['connection_management'])
def delete_connection(connection_id: str):
    """
    Delete a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/connections/{connection_id}', tags=['connection_management'])
def get_connection(connection_id: str):
    """
    Get a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/connections/{connection_id}', tags=['connection_management'])
def patch_connection(
    update_mask: Optional[UpdateMask] = None,
    connection_id: str = ...,
    body: Connection = ...,
):
    """
    Update a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dagSources/{file_token}',
    description=""" Get a source code using file token.
 """,
    tags=['dag_source_management'],
)
def get_dag_source(file_token: str):
    """
    Get a source code
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/dagWarnings', tags=['dag_warning_management', 'dag_management'])
def get_dag_warnings(
    dag_id: Optional[str] = None,
    warning_type: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List dag warnings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags',
    description=""" List DAGs in the database.
`dag_id_pattern` can be set to match dags of a specific pattern
 """,
    tags=['dag_management', 'dag_operations'],
)
def get_dags(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
    tags: Optional[Tags] = None,
    only_active: Optional[bool] = True,
    dag_id_pattern: Optional[str] = None,
):
    """
    List DAGs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags',
    description=""" Update DAGs of a given dag_id_pattern using UpdateMask.
This endpoint allows specifying `~` as the dag_id_pattern to update all DAGs.
*New in version 2.3.0*
 """,
    tags=['dag_management', 'dag_operations'],
)
def patch_dags(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    tags: Optional[Tags] = None,
    update_mask: Optional[UpdateMask] = None,
    only_active: Optional[bool] = True,
    dag_id_pattern: str = ...,
    body: DAG = ...,
):
    """
    Update DAGs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/dags/{dag_id}',
    description=""" Deletes all metadata related to the DAG, including finished DAG Runs and Tasks.
Logs are not deleted. This action cannot be undone.

*New in version 2.2.0*
 """,
    tags=['dag_management', 'dag_operations'],
)
def delete_dag(dag_id: str):
    """
    Delete a DAG
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}',
    description=""" Presents only information available in database (DAGModel).
If you need detailed information, consider using GET /dags/{dag_id}/details.
 """,
    tags=['dag_management', 'dag_operations'],
)
def get_dag(dag_id: str):
    """
    Get basic information about a DAG
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/dags/{dag_id}', tags=['dag_management', 'dag_operations'])
def patch_dag(
    update_mask: Optional[UpdateMask] = None, dag_id: str = ..., body: DAG = ...
):
    """
    Update a DAG
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/{dag_id}/clearTaskInstances',
    description=""" Clears a set of task instances associated with the DAG for a specified date range.
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def post_clear_task_instances(dag_id: str, body: ClearTaskInstances = ...):
    """
    Clear a set of task instances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns',
    description=""" This endpoint allows specifying `~` as the dag_id to retrieve DAG runs for all DAGs.
 """,
    tags=['dag_run_management'],
)
def get_dag_runs(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    execution_date_gte: Optional[datetime] = None,
    execution_date_lte: Optional[datetime] = None,
    start_date_gte: Optional[datetime] = None,
    start_date_lte: Optional[datetime] = None,
    end_date_gte: Optional[datetime] = None,
    end_date_lte: Optional[datetime] = None,
    state: Optional[State1] = None,
    order_by: Optional[str] = None,
    dag_id: str = ...,
):
    """
    List DAG runs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/{dag_id}/dagRuns',
    tags=['dag_run_management', 'dag_management', 'dag_operations'],
)
def post_dag_run(dag_id: str, body: DAGRun = ...):
    """
    Trigger a new DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/dags/{dag_id}/dagRuns/{dag_run_id}', tags=['dag_run_management', 'dag_management']
)
def delete_dag_run(dag_id: str, dag_run_id: str = ...):
    """
    Delete a DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/dags/{dag_id}/dagRuns/{dag_run_id}', tags=['dag_run_management'])
def get_dag_run(dag_id: str, dag_run_id: str = ...):
    """
    Get a DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}',
    description=""" Modify a DAG run.

*New in version 2.2.0*
 """,
    tags=['dag_management', 'dag_run_management'],
)
def update_dag_run_state(
    dag_id: str, dag_run_id: str = ..., body: UpdateDagRunState = ...
):
    """
    Modify a DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/clear',
    description=""" Clear a DAG run.

*New in version 2.4.0*
 """,
    tags=['dag_run_management', 'dag_management'],
)
def clear_dag_run(dag_id: str, dag_run_id: str = ..., body: ClearDagRun = ...):
    """
    Clear a DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/setNote',
    description=""" Update the manual user note of a DagRun.

*New in version 2.5.0*
 """,
    tags=['dag_run_management', 'logging_and_notes_management'],
)
def set_dag_run_note(dag_id: str, dag_run_id: str = ..., body: SetDagRunNote = ...):
    """
    Update the DagRun note.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances',
    description=""" This endpoint allows specifying `~` as the dag_id, dag_run_id to retrieve DAG runs for all DAGs and DAG runs.
 """,
    tags=['task_instance_management', 'dag_run_management', 'dag_operations'],
)
def get_task_instances(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    dag_id: str = ...,
    dag_run_id: str = ...,
    execution_date_gte: Optional[datetime] = None,
    execution_date_lte: Optional[datetime] = None,
    start_date_gte: Optional[datetime] = None,
    start_date_lte: Optional[datetime] = None,
    end_date_gte: Optional[datetime] = None,
    end_date_lte: Optional[datetime] = None,
    duration_gte: Optional[float] = None,
    duration_lte: Optional[float] = None,
    state: Optional[State1] = None,
    pool: Optional[Pool1] = None,
    queue: Optional[Queue] = None,
):
    """
    List task instances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}',
    tags=['task_instance_management', 'dag_run_management'],
)
def get_task_instance(dag_id: str, dag_run_id: str = ..., task_id: str = ...):
    """
    Get a task instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}',
    description=""" Updates the state for single task instance.
*New in version 2.5.0*
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def patch_task_instance(
    dag_id: str,
    dag_run_id: str = ...,
    task_id: str = ...,
    body: UpdateTaskInstance = ...,
):
    """
    Updates the state of a task instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/links',
    description=""" List extra links for task instance.
 """,
    tags=['dag_run_management', 'task_instance_management'],
)
def get_extra_links(dag_id: str, dag_run_id: str = ..., task_id: str = ...):
    """
    List extra links
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/listMapped',
    description=""" Get details of all mapped task instances.

*New in version 2.3.0*
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def get_mapped_task_instances(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    execution_date_gte: Optional[datetime] = None,
    execution_date_lte: Optional[datetime] = None,
    start_date_gte: Optional[datetime] = None,
    start_date_lte: Optional[datetime] = None,
    end_date_gte: Optional[datetime] = None,
    end_date_lte: Optional[datetime] = None,
    duration_gte: Optional[float] = None,
    duration_lte: Optional[float] = None,
    state: Optional[State1] = None,
    pool: Optional[Pool1] = None,
    queue: Optional[Queue] = None,
    order_by: Optional[str] = None,
    dag_id: str = ...,
    dag_run_id: str = ...,
    task_id: str = ...,
):
    """
    List mapped task instances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/logs/{task_try_number}',
    description=""" Get logs for a specific task instance and its try number. """,
    tags=[
        'logging_and_health_management',
        'task_instance_management',
        'dag_run_management',
    ],
)
def get_log(
    dag_id: str,
    dag_run_id: str = ...,
    task_id: str = ...,
    task_try_number: int = ...,
    full_content: Optional[bool] = None,
    map_index: Optional[int] = None,
    token: Optional[str] = None,
):
    """
    Get logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/setNote',
    description=""" Update the manual user note of a non-mapped Task Instance.

*New in version 2.5.0*
 """,
    tags=['task_instance_management', 'logging_and_notes_management'],
)
def set_task_instance_note(
    dag_id: str,
    dag_run_id: str = ...,
    task_id: str = ...,
    body: SetTaskInstanceNote = ...,
):
    """
    Update the TaskInstance note.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries',
    description=""" This endpoint allows specifying `~` as the dag_id, dag_run_id, task_id to retrieve XCOM entries for for all DAGs, DAG runs and task instances. XCom values won't be returned as they can be large. Use this endpoint to get a list of XCom entries and then fetch individual entry to get value. """,
    tags=['xcom_management', 'task_instance_management'],
)
def get_xcom_entries(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    dag_id: str = ...,
    dag_run_id: str = ...,
    task_id: str = ...,
):
    """
    List XCom entries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{xcom_key}',
    tags=['xcom_management', 'task_instance_management'],
)
def get_xcom_entry(
    deserialize: Optional[bool] = False,
    dag_id: str = ...,
    dag_run_id: str = ...,
    task_id: str = ...,
    xcom_key: str = ...,
):
    """
    Get an XCom entry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}',
    description=""" Get details of a mapped task instance.

*New in version 2.3.0*
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def get_mapped_task_instance(
    dag_id: str, dag_run_id: str = ..., task_id: str = ..., map_index: int = ...
):
    """
    Get a mapped task instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}',
    description=""" Updates the state for single mapped task instance.
*New in version 2.5.0*
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def patch_mapped_task_instance(
    dag_id: str,
    dag_run_id: str = ...,
    task_id: str = ...,
    map_index: int = ...,
    body: UpdateTaskInstance = None,
):
    """
    Updates the state of a mapped task instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/{map_index}/setNote',
    description=""" Update the manual user note of a mapped Task Instance.

*New in version 2.5.0*
 """,
    tags=['task_instance_management', 'logging_and_notes_management'],
)
def set_mapped_task_instance_note(
    dag_id: str,
    dag_run_id: str = ...,
    task_id: str = ...,
    map_index: int = ...,
    body: SetTaskInstanceNote = ...,
):
    """
    Update the TaskInstance note.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/dagRuns/{dag_run_id}/upstreamDatasetEvents',
    description=""" Get datasets for a dag run.

*New in version 2.4.0*
 """,
    tags=['dag_run_management', 'dataset_management'],
)
def get_upstream_dataset_events(dag_id: str, dag_run_id: str = ...):
    """
    Get dataset events for a DAG run
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/details',
    description=""" The response contains many DAG attributes, so the response can be large. If possible, consider using GET /dags/{dag_id}.
 """,
    tags=['dag_management', 'dag_operations'],
)
def get_dag_details(dag_id: str):
    """
    Get a simplified representation of DAG
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/tasks',
    tags=['dag_management', 'task_instance_management', 'dag_operations'],
)
def get_tasks(dag_id: str, order_by: Optional[str] = None):
    """
    Get tasks for DAG
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/dags/{dag_id}/tasks/{task_id}',
    tags=['dag_operations', 'task_instance_management'],
)
def get_task(dag_id: str, task_id: str = ...):
    """
    Get simplified representation of a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/{dag_id}/updateTaskInstancesState',
    description=""" Updates the state for multiple task instances simultaneously.
 """,
    tags=['task_instance_management', 'dag_run_management'],
)
def post_set_task_instances_state(dag_id: str, body: UpdateTaskInstancesState = ...):
    """
    Set a state of task instances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/~/dagRuns/list',
    description=""" This endpoint is a POST to allow filtering across a large number of DAG IDs, where as a GET it would run in to maximum HTTP request URL length limit.
 """,
    tags=['dag_run_management'],
)
def get_dag_runs_batch(body: ListDagRunsForm):
    """
    List DAG runs (batch)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/dags/~/dagRuns/~/taskInstances/list',
    description=""" List task instances from all DAGs and DAG runs.
This endpoint is a POST to allow filtering across a large number of DAG IDs, where as a GET it would run in to maximum HTTP request URL length limits.
 """,
    tags=['task_instance_management'],
)
def get_task_instances_batch(body: ListTaskInstanceForm):
    """
    List task instances (batch)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/datasets', tags=['dataset_management'])
def get_datasets(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
    uri_pattern: Optional[str] = None,
):
    """
    List datasets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets/events',
    description=""" Get dataset events """,
    tags=['dataset_management'],
)
def get_dataset_events(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
    dataset_id: Optional[int] = None,
    source_dag_id: Optional[str] = None,
    source_task_id: Optional[str] = None,
    source_run_id: Optional[str] = None,
    source_map_index: Optional[int] = None,
):
    """
    Get dataset events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datasets/{uri}',
    description=""" Get a dataset by uri. """,
    tags=['dataset_management'],
)
def get_dataset(uri: Path):
    """
    Get a dataset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/eventLogs',
    description=""" List log entries from event log. """,
    tags=['logging_and_health_management', 'logging_and_notes_management'],
)
def get_event_logs(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List log entries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/eventLogs/{event_log_id}', tags=['logging_and_health_management'])
def get_event_log(event_log_id: int):
    """
    Get a log entry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health',
    description=""" Get the status of Airflow's metadatabase and scheduler. It includes info about
metadatabase and last heartbeat of scheduler.
 """,
    tags=['logging_and_health_management', 'task_instance_management'],
)
def get_health():
    """
    Get instance status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/importErrors', tags=['logging_and_health_management'])
def get_import_errors(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List import errors
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/importErrors/{import_error_id}', tags=['logging_and_health_management'])
def get_import_error(import_error_id: int):
    """
    Get an import error
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/permissions',
    description=""" Get a list of permissions.

*New in version 2.1.0*
 """,
    tags=['permission_management'],
)
def get_permissions(limit: Optional[int] = 100, offset: Optional[conint(ge=0)] = None):
    """
    List permissions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/plugins',
    description=""" Get a list of loaded plugins.

*New in version 2.1.0*
 """,
    tags=['plugin_management'],
)
def get_plugins(limit: Optional[int] = 100, offset: Optional[conint(ge=0)] = None):
    """
    Get a list of loaded plugins
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/pools', tags=['pool_management'])
def get_pools(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List pools
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pools', tags=['pool_management'])
def post_pool(body: Pool):
    """
    Create a pool
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/pools/{pool_name}', tags=['pool_management'])
def delete_pool(pool_name: str):
    """
    Delete a pool
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/pools/{pool_name}', tags=['pool_management'])
def get_pool(pool_name: str):
    """
    Get a pool
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch('/pools/{pool_name}', tags=['pool_management'])
def patch_pool(
    update_mask: Optional[UpdateMask] = None, pool_name: str = ..., body: Pool = ...
):
    """
    Update a pool
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/providers',
    description=""" Get a list of providers.

*New in version 2.1.0*
 """,
    tags=['dataset_management', 'plugin_management', 'variable_management'],
)
def get_providers():
    """
    List providers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles',
    description=""" Get a list of roles.

*New in version 2.1.0*
 """,
    tags=['role_management', 'permission_management'],
)
def get_roles(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List roles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/roles',
    description=""" Create a new role.

*New in version 2.1.0*
 """,
    tags=['role_management', 'permission_management'],
)
def post_role(body: Role):
    """
    Create a role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/roles/{role_name}',
    description=""" Delete a role.

*New in version 2.1.0*
 """,
    tags=['permission_management', 'role_management'],
)
def delete_role(role_name: str):
    """
    Delete a role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles/{role_name}',
    description=""" Get a role.

*New in version 2.1.0*
 """,
    tags=['role_management', 'permission_management'],
)
def get_role(role_name: str):
    """
    Get a role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/roles/{role_name}',
    description=""" Update a role.

*New in version 2.1.0*
 """,
    tags=['role_management', 'permission_management'],
)
def patch_role(
    update_mask: Optional[UpdateMask] = None, role_name: str = ..., body: Role = ...
):
    """
    Update a role
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" Get a list of users.

*New in version 2.1.0*
 """,
    tags=['user_management'],
)
def get_users(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users',
    description=""" Create a new user with unique username and email.

*New in version 2.2.0*
 """,
    tags=['user_management'],
)
def post_user(body: User):
    """
    Create a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/{username}',
    description=""" Delete a user with a specific username.

*New in version 2.2.0*
 """,
    tags=['user_management', 'permission_management'],
)
def delete_user(username: str):
    """
    Delete a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{username}',
    description=""" Get a user with a specific username.

*New in version 2.1.0*
 """,
    tags=['user_management'],
)
def get_user(username: str):
    """
    Get a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/users/{username}',
    description=""" Update fields for a user.

*New in version 2.2.0*
 """,
    tags=['user_management', 'permission_management', 'role_management'],
)
def patch_user(
    update_mask: Optional[UpdateMask] = None, username: str = ..., body: User = ...
):
    """
    Update a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variables',
    description=""" The collection does not contain data. To get data, you must get a single entity. """,
    tags=['variable_management'],
)
def get_variables(
    limit: Optional[int] = 100,
    offset: Optional[conint(ge=0)] = None,
    order_by: Optional[str] = None,
):
    """
    List variables
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/variables', tags=['variable_management'])
def post_variables(body: Variable):
    """
    Create a variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/variables/{variable_key}', tags=['variable_management'])
def delete_variable(variable_key: Path):
    """
    Delete a variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variables/{variable_key}',
    description=""" Get a variable by key. """,
    tags=['variable_management'],
)
def get_variable(variable_key: Path):
    """
    Get a variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/variables/{variable_key}',
    description=""" Update a variable by key. """,
    tags=['variable_management'],
)
def patch_variable(
    update_mask: Optional[UpdateMask] = None,
    variable_key: Path = ...,
    body: Variable = ...,
):
    """
    Update a variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/version', tags=['version_management'])
def get_version():
    """
    Get version information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
