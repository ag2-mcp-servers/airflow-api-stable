# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:27:08+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel, SecretStr, conint, constr


class Action(BaseModel):
    name: Optional[str] = Field(None, description='The name of the permission "action"')


class ClassReference(BaseModel):
    class_name: Optional[str] = None
    module_path: Optional[str] = None


class ClearDagRun(BaseModel):
    dry_run: Optional[bool] = Field(
        True,
        description="If set, don't actually run this operation. The response will contain a list of task instances\nplanned to be cleaned, but not modified in any way.\n",
    )


class ClearTaskInstances(BaseModel):
    dag_run_id: Optional[str] = Field(
        None, description='The DagRun ID for this task instance'
    )
    dry_run: Optional[bool] = Field(
        True,
        description="If set, don't actually run this operation. The response will contain a list of task instances\nplanned to be cleaned, but not modified in any way.\n",
    )
    end_date: Optional[str] = Field(
        None, description='The maximum execution date to clear.'
    )
    include_downstream: Optional[bool] = Field(
        False, description='If set to true, downstream tasks are also affected.'
    )
    include_future: Optional[bool] = Field(
        False,
        description='If set to True, also tasks from future DAG Runs are affected.',
    )
    include_parentdag: Optional[bool] = Field(
        None, description='Clear tasks in the parent dag of the subdag.'
    )
    include_past: Optional[bool] = Field(
        False, description='If set to True, also tasks from past DAG Runs are affected.'
    )
    include_subdags: Optional[bool] = Field(
        None,
        description='Clear tasks in subdags and clear external tasks indicated by ExternalTaskMarker.',
    )
    include_upstream: Optional[bool] = Field(
        False, description='If set to true, upstream tasks are also affected.'
    )
    only_failed: Optional[bool] = Field(True, description='Only clear failed tasks.')
    only_running: Optional[bool] = Field(False, description='Only clear running tasks.')
    reset_dag_runs: Optional[bool] = Field(
        None, description='Set state of DAG runs to RUNNING.'
    )
    start_date: Optional[str] = Field(
        None, description='The minimum execution date to clear.'
    )
    task_ids: Optional[List[str]] = Field(
        None,
        description='A list of task ids to clear.\n\n*New in version 2.1.0*\n',
        min_length=1,
    )


class CollectionInfo(BaseModel):
    total_entries: Optional[int] = Field(
        None, description='Count of objects in the current result set.'
    )


class Color(RootModel[constr(pattern=r'^#[a-fA-F0-9]{3,6}$')]):
    root: constr(pattern=r'^#[a-fA-F0-9]{3,6}$') = Field(
        ..., description='Color in hexadecimal notation.'
    )


class ConfigOption(BaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class ConfigSection(BaseModel):
    name: Optional[str] = None
    options: Optional[List[ConfigOption]] = None


class ConnectionCollectionItem(BaseModel):
    conn_type: Optional[str] = Field(None, description='The connection type.')
    connection_id: Optional[str] = Field(None, description='The connection ID.')
    description: Optional[str] = Field(
        None, description='The description of the connection.'
    )
    host: Optional[str] = Field(None, description='Host of the connection.')
    login: Optional[str] = Field(None, description='Login of the connection.')
    port: Optional[int] = Field(None, description='Port of the connection.')
    schema_: Optional[str] = Field(
        None, alias='schema', description='Schema of the connection.'
    )


class ConnectionTest(BaseModel):
    message: Optional[str] = Field(
        None, description='The success or failure message of the request.'
    )
    status: Optional[bool] = Field(None, description='The status of the request.')


class CronExpression(BaseModel):
    field__type: Literal['CronExpression'] = Field(..., alias='__type')
    value: str


class RunType(Enum):
    backfill = 'backfill'
    manual = 'manual'
    scheduled = 'scheduled'
    dataset_triggered = 'dataset_triggered'


class DagScheduleDatasetReference(BaseModel):
    created_at: Optional[str] = Field(
        None, description='The dataset reference creation time'
    )
    dag_id: Optional[str] = Field(
        None, description='The DAG ID that depends on the dataset.'
    )
    updated_at: Optional[str] = Field(
        None, description='The dataset reference update time'
    )


class DagState(Enum):
    queued = 'queued'
    running = 'running'
    success = 'success'
    failed = 'failed'


class DagWarning(BaseModel):
    dag_id: Optional[str] = Field(None, description='The dag_id.')
    message: Optional[str] = Field(None, description='The message for the dag warning.')
    timestamp: Optional[str] = Field(
        None, description='The time when this warning was logged.'
    )
    warning_type: Optional[str] = Field(
        None, description='The warning type for the dag warning.'
    )


class DagWarningCollection(CollectionInfo):
    import_errors: Optional[List[DagWarning]] = None


class Error(BaseModel):
    detail: Optional[str] = Field(
        None,
        description='A human-readable explanation specific to this occurrence of the problem.',
    )
    instance: Optional[str] = Field(
        None,
        description='A URI reference that identifies the specific occurrence of the problem. It may or may\nnot yield further information if dereferenced.\n',
    )
    status: float = Field(
        ...,
        description='The HTTP status code generated by the API server for this occurrence of the problem.',
    )
    title: str = Field(
        ..., description='A short, human-readable summary of the problem type.'
    )
    type: str = Field(
        ...,
        description='A URI reference [RFC3986] that identifies the problem type. This specification\nencourages that, when dereferenced, it provide human-readable documentation for\nthe problem type.\n',
    )


class EventLog(BaseModel):
    dag_id: Optional[str] = Field(None, description='The DAG ID')
    event: Optional[str] = Field(
        None, description='A key describing the type of event.'
    )
    event_log_id: Optional[int] = Field(None, description='The event log ID')
    execution_date: Optional[datetime] = Field(
        None,
        description='When the event was dispatched for an object having execution_date, the value of this field.\n',
    )
    extra: Optional[str] = Field(
        None,
        description='Other information that was not included in the other fields, e.g. the complete CLI command.\n',
    )
    owner: Optional[str] = Field(
        None, description='Name of the user who triggered these events a.'
    )
    task_id: Optional[str] = Field(None, description='The DAG ID')
    when: Optional[datetime] = Field(
        None, description='The time when these events happened.'
    )


class EventLogCollection(CollectionInfo):
    event_logs: Optional[List[EventLog]] = None


class ExtraLink(BaseModel):
    class_ref: Optional[ClassReference] = None
    href: Optional[str] = None
    name: Optional[str] = None


class ExtraLinkCollection(BaseModel):
    extra_links: Optional[List[ExtraLink]] = None


class HealthStatus(Enum):
    healthy = 'healthy'
    unhealthy = 'unhealthy'


class ImportError(BaseModel):
    filename: Optional[str] = Field(None, description='The filename')
    import_error_id: Optional[int] = Field(None, description='The import error ID.')
    stack_trace: Optional[str] = Field(None, description='The full stackstrace..')
    timestamp: Optional[str] = Field(
        None, description='The time when this error was created.'
    )


class ImportErrorCollection(CollectionInfo):
    import_errors: Optional[List[ImportError]] = None


class Job(BaseModel):
    dag_id: Optional[str] = None
    end_date: Optional[str] = None
    executor_class: Optional[str] = None
    hostname: Optional[str] = None
    id: Optional[int] = None
    job_type: Optional[str] = None
    latest_heartbeat: Optional[str] = None
    start_date: Optional[str] = None
    state: Optional[str] = None
    unixname: Optional[str] = None


class ListDagRunsForm(BaseModel):
    dag_ids: Optional[List[str]] = Field(
        None,
        description='Return objects with specific DAG IDs.\nThe value can be repeated to retrieve multiple matching values (OR condition).',
    )
    end_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal the specified date.\n\nThis can be combined with end_date_lte parameter to receive only the selected period.\n',
    )
    end_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less than or equal to the specified date.\n\nThis can be combined with end_date_gte parameter to receive only the selected period.\n',
    )
    execution_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal to the specified date.\n\nThis can be combined with execution_date_lte key to receive only the selected period.\n',
    )
    execution_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less than or equal to the specified date.\n\nThis can be combined with execution_date_gte key to receive only the selected period.\n',
    )
    order_by: Optional[str] = Field(
        None,
        description='The name of the field to order the results by. Prefix a field name\nwith `-` to reverse the sort order.\n\n*New in version 2.1.0*\n',
    )
    page_limit: Optional[conint(ge=1)] = Field(
        100, description='The numbers of items to return.'
    )
    page_offset: Optional[conint(ge=0)] = Field(
        None,
        description='The number of items to skip before starting to collect the result set.',
    )
    start_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal the specified date.\n\nThis can be combined with start_date_lte key to receive only the selected period.\n',
    )
    start_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less or equal the specified date.\n\nThis can be combined with start_date_gte parameter to receive only the selected period\n',
    )
    states: Optional[List[str]] = Field(
        None,
        description='Return objects with specific states.\nThe value can be repeated to retrieve multiple matching values (OR condition).',
    )


class MetadatabaseStatus(BaseModel):
    status: Optional[HealthStatus] = None


class PluginCollectionItem(BaseModel):
    appbuilder_menu_items: Optional[List[Dict[str, Any]]] = Field(
        None, description='The Flask Appbuilder menu items'
    )
    appbuilder_views: Optional[List[Dict[str, Any]]] = Field(
        None, description='The appuilder views'
    )
    executors: Optional[List[str]] = Field(None, description='The plugin executors')
    flask_blueprints: Optional[List[Dict[str, Any]]] = Field(
        None, description='The flask blueprints'
    )
    global_operator_extra_links: Optional[List[Dict[str, Any]]] = Field(
        None, description='The global operator extra links'
    )
    hooks: Optional[List[str]] = Field(None, description='The plugin hooks')
    macros: Optional[List[Dict[str, Any]]] = Field(
        None, description='The plugin macros'
    )
    name: Optional[str] = Field(None, description='The name of the plugin')
    operator_extra_links: Optional[List[Dict[str, Any]]] = Field(
        None, description='Operator extra links'
    )
    source: Optional[str] = Field(None, description='The plugin source')


class Pool(BaseModel):
    description: Optional[str] = Field(
        None, description='The description of the pool.\n\n*New in version 2.3.0*\n'
    )
    name: Optional[str] = Field(None, description='The name of pool.')
    occupied_slots: Optional[int] = Field(
        None,
        description='The number of slots used by running/queued tasks at the moment.',
    )
    open_slots: Optional[int] = Field(
        None, description='The number of free slots at the moment.'
    )
    queued_slots: Optional[int] = Field(
        None, description='The number of slots used by queued tasks at the moment.'
    )
    slots: Optional[int] = Field(
        None,
        description='The maximum number of slots that can be assigned to tasks. One job may occupy one or more slots.\n',
    )
    used_slots: Optional[int] = Field(
        None, description='The number of slots used by running tasks at the moment.'
    )


class PoolCollection(CollectionInfo):
    pools: Optional[List[Pool]] = None


class Provider(BaseModel):
    description: Optional[str] = Field(
        None, description='The description of the provider.'
    )
    package_name: Optional[str] = Field(
        None, description='The package name of the provider.'
    )
    version: Optional[str] = Field(None, description='The version of the provider.')


class ProviderCollection(BaseModel):
    providers: Optional[List[Provider]] = None


class RelativeDelta(BaseModel):
    field__type: Literal['RelativeDelta'] = Field(..., alias='__type')
    day: int
    days: int
    hour: int
    hours: int
    leapdays: int
    microsecond: int
    microseconds: int
    minute: int
    minutes: int
    month: int
    months: int
    second: int
    seconds: int
    year: int
    years: int


class Resource(BaseModel):
    name: Optional[str] = Field(None, description='The name of the resource')


class SLAMiss(BaseModel):
    dag_id: Optional[str] = Field(None, description='The DAG ID.')
    description: Optional[str] = None
    email_sent: Optional[bool] = None
    execution_date: Optional[str] = None
    notification_sent: Optional[bool] = None
    task_id: Optional[str] = Field(None, description='The task ID.')
    timestamp: Optional[str] = None


class SchedulerStatus(BaseModel):
    latest_scheduler_heartbeat: Optional[str] = Field(
        None, description='The time the scheduler last do a heartbeat.'
    )
    status: Optional[HealthStatus] = None


class SetDagRunNote(BaseModel):
    note: Optional[str] = Field(
        None, description='Custom notes left by users for this Dag Run.'
    )


class SetTaskInstanceNote(BaseModel):
    note: str = Field(..., description='The custom note to set for this Task Instance.')


class Tag(BaseModel):
    name: Optional[str] = None


class ExtraLink1(BaseModel):
    class_ref: Optional[ClassReference] = None


class TaskInstanceReference(BaseModel):
    dag_id: Optional[str] = Field(None, description='The DAG ID.')
    dag_run_id: Optional[str] = Field(None, description='The DAG run ID.')
    execution_date: Optional[str] = None
    task_id: Optional[str] = Field(None, description='The task ID.')


class TaskInstanceReferenceCollection(BaseModel):
    task_instances: Optional[List[TaskInstanceReference]] = None


class TaskOutletDatasetReference(BaseModel):
    created_at: Optional[str] = Field(None, description='The dataset creation time')
    dag_id: Optional[str] = Field(
        None, description='The DAG ID that updates the dataset.'
    )
    task_id: Optional[str] = Field(
        None, description='The task ID that updates the dataset.'
    )
    updated_at: Optional[str] = Field(None, description='The dataset update time')


class TaskState(Enum):
    success = 'success'
    running = 'running'
    failed = 'failed'
    upstream_failed = 'upstream_failed'
    skipped = 'skipped'
    up_for_retry = 'up_for_retry'
    up_for_reschedule = 'up_for_reschedule'
    queued = 'queued'
    none = 'none'
    scheduled = 'scheduled'
    deferred = 'deferred'
    removed = 'removed'
    restarting = 'restarting'


class TimeDelta(BaseModel):
    field__type: Literal['TimeDelta'] = Field(..., alias='__type')
    days: int
    microseconds: int
    seconds: int


class Timezone(RootModel[str]):
    root: str


class Trigger(BaseModel):
    classpath: Optional[str] = None
    created_date: Optional[str] = None
    id: Optional[int] = None
    kwargs: Optional[str] = None
    triggerer_id: Optional[int] = None


class TriggerRule(Enum):
    all_success = 'all_success'
    all_failed = 'all_failed'
    all_done = 'all_done'
    one_success = 'one_success'
    one_failed = 'one_failed'
    none_failed = 'none_failed'
    none_skipped = 'none_skipped'
    none_failed_or_skipped = 'none_failed_or_skipped'
    none_failed_min_one_success = 'none_failed_min_one_success'
    dummy = 'dummy'


class State(Enum):
    success = 'success'
    failed = 'failed'
    queued = 'queued'


class UpdateDagRunState(BaseModel):
    state: Optional[State] = Field(None, description='The state to set this DagRun')


class NewState(Enum):
    success = 'success'
    failed = 'failed'


class UpdateTaskInstance(BaseModel):
    dry_run: Optional[bool] = Field(
        False,
        description="If set, don't actually run this operation. The response will contain the task instance\nplanned to be affected, but won't be modified in any way.\n",
    )
    new_state: Optional[NewState] = Field(None, description='Expected new state.')


class UpdateTaskInstancesState(BaseModel):
    dag_run_id: Optional[str] = Field(
        None,
        description="The task instance's DAG run ID. Either set this or execution_date but not both.\n\n*New in version 2.3.0*\n",
    )
    dry_run: Optional[bool] = Field(
        True,
        description="If set, don't actually run this operation. The response will contain a list of task instances\nplanned to be affected, but won't be modified in any way.\n",
    )
    execution_date: Optional[str] = Field(
        None,
        description='The execution date. Either set this or dag_run_id but not both.',
    )
    include_downstream: Optional[bool] = Field(
        None, description='If set to true, downstream tasks are also affected.'
    )
    include_future: Optional[bool] = Field(
        None,
        description='If set to True, also tasks from future DAG Runs are affected.',
    )
    include_past: Optional[bool] = Field(
        None, description='If set to True, also tasks from past DAG Runs are affected.'
    )
    include_upstream: Optional[bool] = Field(
        None, description='If set to true, upstream tasks are also affected.'
    )
    new_state: Optional[NewState] = Field(None, description='Expected new state.')
    task_id: Optional[str] = Field(None, description='The task ID.')


class Role1(BaseModel):
    name: Optional[str] = None


class UserCollectionItem(BaseModel):
    active: Optional[bool] = Field(None, description='Whether the user is active')
    changed_on: Optional[str] = Field(None, description='The date user was changed')
    created_on: Optional[str] = Field(None, description='The date user was created')
    email: Optional[constr(min_length=1)] = Field(
        None,
        description="The user's email.\n\n*Changed in version 2.2.0*&#58; A minimum character length requirement ('minLength') is added.\n",
    )
    failed_login_count: Optional[int] = Field(
        None, description='The number of times the login failed'
    )
    first_name: Optional[str] = Field(
        None,
        description="The user's first name.\n\n*Changed in version 2.4.0*&#58; The requirement for this to be non-empty was removed.\n",
    )
    last_login: Optional[str] = Field(None, description='The last user login')
    last_name: Optional[str] = Field(
        None,
        description="The user's last name.\n\n*Changed in version 2.4.0*&#58; The requirement for this to be non-empty was removed.\n",
    )
    login_count: Optional[int] = Field(None, description='The login count')
    roles: Optional[List[Role1]] = Field(
        None,
        description='User roles.\n\n*Changed in version 2.2.0*&#58; Field is no longer read-only.\n',
    )
    username: Optional[constr(min_length=1)] = Field(
        None,
        description="The username.\n\n*Changed in version 2.2.0*&#58; A minimum character length requirement ('minLength') is added.\n",
    )


class VariableCollectionItem(BaseModel):
    description: Optional[str] = Field(
        None, description='The description of the variable.\n\n*New in version 2.4.0*\n'
    )
    key: Optional[str] = None


class VersionInfo(BaseModel):
    git_version: Optional[str] = Field(
        None, description='The git version (including git commit hash)'
    )
    version: Optional[str] = Field(None, description='The version of Airflow')


class WeightRule(Enum):
    downstream = 'downstream'
    upstream = 'upstream'
    absolute = 'absolute'


class XComCollectionItem(BaseModel):
    dag_id: Optional[str] = None
    execution_date: Optional[str] = None
    key: Optional[str] = None
    task_id: Optional[str] = None
    timestamp: Optional[str] = None


class UpdateMask(RootModel[List[str]]):
    root: List[str]


class DagSourcesFileTokenGetResponse(BaseModel):
    content: Optional[str] = None


class Tags(RootModel[List[str]]):
    root: List[str]


class State1(RootModel[List[str]]):
    root: List[str]


class Pool1(RootModel[List[str]]):
    root: List[str]


class Queue(RootModel[List[str]]):
    root: List[str]


class DagsDagIdDagRunsDagRunIdTaskInstancesTaskIdLogsTaskTryNumberGetResponse(
    BaseModel
):
    content: Optional[str] = None
    continuation_token: Optional[str] = None


class ProvidersGetResponse(ProviderCollection, CollectionInfo):
    pass


class ActionCollection(CollectionInfo):
    actions: Optional[List[Action]] = None


class ActionResource(BaseModel):
    action: Optional[Action] = Field(None, description='The permission action')
    resource: Optional[Resource] = Field(None, description='The permission resource')


class BasicDAGRun(BaseModel):
    dag_id: Optional[str] = None
    data_interval_end: Optional[datetime] = None
    data_interval_start: Optional[datetime] = None
    end_date: Optional[datetime] = None
    logical_date: Optional[datetime] = Field(
        None,
        description='The logical date (previously called execution date). This is the time or interval covered by\nthis DAG run, according to the DAG definition.\n\nThe value of this field can be set only when creating the object. If you try to modify the\nfield of an existing object, the request fails with an BAD_REQUEST error.\n\nThis together with DAG_ID are a unique key.\n\n*New in version 2.2.0*\n',
    )
    run_id: Optional[str] = Field(None, description='Run ID.\n')
    start_date: Optional[datetime] = Field(
        None,
        description='The start time. The time when DAG run was actually created.\n\n*Changed in version 2.1.3*&#58; Field becomes nullable.\n',
    )
    state: Optional[DagState] = None


class Config(BaseModel):
    sections: Optional[List[ConfigSection]] = None


class Connection(ConnectionCollectionItem):
    extra: Optional[str] = Field(
        None,
        description='Other values that cannot be put into another field, e.g. RSA keys.',
    )
    password: Optional[SecretStr] = Field(
        None, description='Password of the connection.'
    )


class ConnectionCollection(CollectionInfo):
    connections: Optional[List[ConnectionCollectionItem]] = None


class DAGRun(BaseModel):
    conf: Optional[Dict[str, Any]] = Field(
        None,
        description='JSON object describing additional configuration parameters.\n\nThe value of this field can be set only when creating the object. If you try to modify the\nfield of an existing object, the request fails with an BAD_REQUEST error.\n',
    )
    dag_id: Optional[str] = None
    dag_run_id: Optional[str] = Field(
        None,
        description='Run ID.\n\nThe value of this field can be set only when creating the object. If you try to modify the\nfield of an existing object, the request fails with an BAD_REQUEST error.\n\nIf not provided, a value will be generated based on execution_date.\n\nIf the specified dag_run_id is in use, the creation request fails with an ALREADY_EXISTS error.\n\nThis together with DAG_ID are a unique key.\n',
    )
    data_interval_end: Optional[datetime] = None
    data_interval_start: Optional[datetime] = None
    end_date: Optional[datetime] = None
    execution_date: Optional[datetime] = Field(
        None,
        description="The execution date. This is the same as logical_date, kept for backwards compatibility.\nIf both this field and logical_date are provided but with different values, the request\nwill fail with an BAD_REQUEST error.\n\n*Changed in version 2.2.0*&#58; Field becomes nullable.\n\n*Deprecated since version 2.2.0*&#58; Use 'logical_date' instead.\n",
    )
    external_trigger: Optional[bool] = True
    last_scheduling_decision: Optional[datetime] = None
    logical_date: Optional[datetime] = Field(
        None,
        description='The logical date (previously called execution date). This is the time or interval covered by\nthis DAG run, according to the DAG definition.\n\nThe value of this field can be set only when creating the object. If you try to modify the\nfield of an existing object, the request fails with an BAD_REQUEST error.\n\nThis together with DAG_ID are a unique key.\n\n*New in version 2.2.0*\n',
    )
    note: Optional[str] = Field(
        None,
        description='Contains manually entered notes by the user about the DagRun.\n\n*New in version 2.5.0*\n',
    )
    run_type: Optional[RunType] = None
    start_date: Optional[datetime] = Field(
        None,
        description='The start time. The time when DAG run was actually created.\n\n*Changed in version 2.1.3*&#58; Field becomes nullable.\n',
    )
    state: Optional[DagState] = None


class DAGRunCollection(CollectionInfo):
    dag_runs: Optional[List[DAGRun]] = None


class Dataset(BaseModel):
    consuming_dags: Optional[List[DagScheduleDatasetReference]] = None
    created_at: Optional[str] = Field(None, description='The dataset creation time')
    extra: Optional[Dict[str, Any]] = Field(None, description='The dataset extra')
    id: Optional[int] = Field(None, description='The dataset id')
    producing_tasks: Optional[List[TaskOutletDatasetReference]] = None
    updated_at: Optional[str] = Field(None, description='The dataset update time')
    uri: Optional[str] = Field(None, description='The dataset uri')


class DatasetCollection(CollectionInfo):
    datasets: Optional[List[Dataset]] = None


class DatasetEvent(BaseModel):
    created_dagruns: Optional[List[BasicDAGRun]] = None
    dataset_id: Optional[int] = Field(None, description='The dataset id')
    dataset_uri: Optional[str] = Field(None, description='The URI of the dataset')
    extra: Optional[Dict[str, Any]] = Field(None, description='The dataset event extra')
    source_dag_id: Optional[str] = Field(
        None, description='The DAG ID that updated the dataset.'
    )
    source_map_index: Optional[int] = Field(
        None, description='The task map index that updated the dataset.'
    )
    source_run_id: Optional[str] = Field(
        None, description='The DAG run ID that updated the dataset.'
    )
    source_task_id: Optional[str] = Field(
        None, description='The task ID that updated the dataset.'
    )
    timestamp: Optional[str] = Field(
        None, description='The dataset event creation time'
    )


class DatasetEventCollection(CollectionInfo):
    dataset_events: Optional[List[DatasetEvent]] = None


class HealthInfo(BaseModel):
    metadatabase: Optional[MetadatabaseStatus] = None
    scheduler: Optional[SchedulerStatus] = None


class ListTaskInstanceForm(BaseModel):
    dag_ids: Optional[List[str]] = Field(
        None,
        description='Return objects with specific DAG IDs.\nThe value can be repeated to retrieve multiple matching values (OR condition).',
    )
    duration_gte: Optional[float] = Field(
        None,
        description='Returns objects greater than or equal to the specified values.\n\nThis can be combined with duration_lte parameter to receive only the selected period.\n',
    )
    duration_lte: Optional[float] = Field(
        None,
        description='Returns objects less than or equal to the specified values.\n\nThis can be combined with duration_gte parameter to receive only the selected range.\n',
    )
    end_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal the specified date.\n\nThis can be combined with start_date_lte parameter to receive only the selected period.\n',
    )
    end_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less than or equal to the specified date.\n\nThis can be combined with start_date_gte parameter to receive only the selected period.\n',
    )
    execution_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal to the specified date.\n\nThis can be combined with execution_date_lte parameter to receive only the selected period.\n',
    )
    execution_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less than or equal to the specified date.\n\nThis can be combined with execution_date_gte parameter to receive only the selected period.\n',
    )
    pool: Optional[List[str]] = Field(
        None,
        description='The value can be repeated to retrieve multiple matching values (OR condition).',
    )
    queue: Optional[List[str]] = Field(
        None,
        description='The value can be repeated to retrieve multiple matching values (OR condition).',
    )
    start_date_gte: Optional[datetime] = Field(
        None,
        description='Returns objects greater or equal the specified date.\n\nThis can be combined with start_date_lte parameter to receive only the selected period.\n',
    )
    start_date_lte: Optional[datetime] = Field(
        None,
        description='Returns objects less or equal the specified date.\n\nThis can be combined with start_date_gte parameter to receive only the selected period.\n',
    )
    state: Optional[List[TaskState]] = Field(
        None,
        description='The value can be repeated to retrieve multiple matching values (OR condition).',
    )


class PluginCollection(CollectionInfo):
    plugins: Optional[List[PluginCollectionItem]] = None


class Role(BaseModel):
    actions: Optional[List[ActionResource]] = None
    name: Optional[constr(min_length=1)] = Field(
        None,
        description="The name of the role\n\n*Changed in version 2.3.0*&#58; A minimum character length requirement ('minLength') is added.\n",
    )


class RoleCollection(CollectionInfo):
    roles: Optional[List[Role]] = None


class ScheduleInterval(
    RootModel[Optional[Union[TimeDelta, RelativeDelta, CronExpression]]]
):
    root: Optional[Union[TimeDelta, RelativeDelta, CronExpression]] = Field(
        None,
        description="Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's\nexecution_date to figure out the next schedule.\n",
        discriminator='field__type',
    )


class TaskInstance(BaseModel):
    dag_id: Optional[str] = None
    dag_run_id: Optional[str] = Field(
        None,
        description='The DagRun ID for this task instance\n\n*New in version 2.3.0*\n',
    )
    duration: Optional[float] = None
    end_date: Optional[str] = None
    execution_date: Optional[str] = None
    executor_config: Optional[str] = None
    hostname: Optional[str] = None
    map_index: Optional[int] = None
    max_tries: Optional[int] = None
    note: Optional[str] = Field(
        None,
        description='Contains manually entered notes by the user about the TaskInstance.\n\n*New in version 2.5.0*\n',
    )
    operator: Optional[str] = Field(
        None, description='*Changed in version 2.1.1*&#58; Field becomes nullable.\n'
    )
    pid: Optional[int] = None
    pool: Optional[str] = None
    pool_slots: Optional[int] = None
    priority_weight: Optional[int] = None
    queue: Optional[str] = None
    queued_when: Optional[str] = None
    rendered_fields: Optional[Dict[str, Any]] = Field(
        None,
        description='JSON object describing rendered fields.\n\n*New in version 2.3.0*\n',
    )
    sla_miss: Optional[SLAMiss] = None
    start_date: Optional[str] = None
    state: Optional[TaskState] = None
    task_id: Optional[str] = None
    trigger: Optional[Trigger] = None
    triggerer_job: Optional[Job] = None
    try_number: Optional[int] = None
    unixname: Optional[str] = None


class TaskInstanceCollection(CollectionInfo):
    task_instances: Optional[List[TaskInstance]] = None


class User(UserCollectionItem):
    password: Optional[str] = None


class UserCollection(CollectionInfo):
    users: Optional[List[UserCollectionItem]] = None


class Variable(VariableCollectionItem):
    value: Optional[str] = None


class VariableCollection(CollectionInfo):
    variables: Optional[List[VariableCollectionItem]] = None


class XCom(XComCollectionItem):
    value: Optional[str] = Field(None, description='The value')


class XComCollection(CollectionInfo):
    xcom_entries: Optional[List[XComCollectionItem]] = None


class DAG(BaseModel):
    dag_id: Optional[str] = Field(None, description='The ID of the DAG.')
    default_view: Optional[str] = Field(
        None,
        description='Default view of the DAG inside the webserver\n\n*New in version 2.3.0*\n',
    )
    description: Optional[str] = Field(
        None,
        description='User-provided DAG description, which can consist of several sentences or paragraphs that describe DAG contents.\n',
    )
    file_token: Optional[str] = Field(
        None,
        description='The key containing the encrypted path to the file. Encryption and decryption take place only on the server. This prevents the client from reading an non-DAG file. This also ensures API extensibility, because the format of encrypted data may change.\n',
    )
    fileloc: Optional[str] = Field(None, description='The absolute path to the file.')
    has_import_errors: Optional[bool] = Field(
        None,
        description='Whether the DAG has import errors\n\n*New in version 2.3.0*\n',
    )
    has_task_concurrency_limits: Optional[bool] = Field(
        None,
        description='Whether the DAG has task concurrency limits\n\n*New in version 2.3.0*\n',
    )
    is_active: Optional[bool] = Field(
        None,
        description='Whether the DAG is currently seen by the scheduler(s).\n\n*New in version 2.1.1*\n\n*Changed in version 2.2.0*&#58; Field is read-only.\n',
    )
    is_paused: Optional[bool] = Field(None, description='Whether the DAG is paused.')
    is_subdag: Optional[bool] = Field(None, description='Whether the DAG is SubDAG.')
    last_expired: Optional[datetime] = Field(
        None,
        description='Time when the DAG last received a refresh signal\n(e.g. the DAG\'s "refresh" button was clicked in the web UI)\n\n*New in version 2.3.0*\n',
    )
    last_parsed_time: Optional[datetime] = Field(
        None,
        description='The last time the DAG was parsed.\n\n*New in version 2.3.0*\n',
    )
    last_pickled: Optional[datetime] = Field(
        None,
        description='The last time the DAG was pickled.\n\n*New in version 2.3.0*\n',
    )
    max_active_runs: Optional[int] = Field(
        None,
        description='Maximum number of active DAG runs for the DAG\n\n*New in version 2.3.0*\n',
    )
    max_active_tasks: Optional[int] = Field(
        None,
        description='Maximum number of active tasks that can be run on the DAG\n\n*New in version 2.3.0*\n',
    )
    next_dagrun: Optional[datetime] = Field(
        None,
        description='The logical date of the next dag run.\n\n*New in version 2.3.0*\n',
    )
    next_dagrun_create_after: Optional[datetime] = Field(
        None,
        description='Earliest time at which this ``next_dagrun`` can be created.\n\n*New in version 2.3.0*\n',
    )
    next_dagrun_data_interval_end: Optional[datetime] = Field(
        None,
        description='The end of the interval of the next dag run.\n\n*New in version 2.3.0*\n',
    )
    next_dagrun_data_interval_start: Optional[datetime] = Field(
        None,
        description='The start of the interval of the next dag run.\n\n*New in version 2.3.0*\n',
    )
    owners: Optional[List[str]] = None
    pickle_id: Optional[str] = Field(
        None,
        description='Foreign key to the latest pickle_id\n\n*New in version 2.3.0*\n',
    )
    root_dag_id: Optional[str] = Field(
        None,
        description='If the DAG is SubDAG then it is the top level DAG identifier. Otherwise, null.',
    )
    schedule_interval: Optional[ScheduleInterval] = None
    scheduler_lock: Optional[bool] = Field(
        None,
        description='Whether (one of) the scheduler is scheduling this DAG at the moment\n\n*New in version 2.3.0*\n',
    )
    tags: Optional[List[Tag]] = Field(None, description='List of tags.')
    timetable_description: Optional[str] = Field(
        None,
        description='Timetable/Schedule Interval description.\n\n*New in version 2.3.0*\n',
    )


class DAGCollection(CollectionInfo):
    dags: Optional[List[DAG]] = None


class DAGDetail(DAG):
    catchup: Optional[bool] = None
    concurrency: Optional[float] = None
    dag_run_timeout: Optional[TimeDelta] = None
    default_view: Optional[str] = None
    doc_md: Optional[str] = None
    end_date: Optional[datetime] = Field(
        None, description="The DAG's end date.\n\n*New in version 2.3.0*.\n"
    )
    is_paused_upon_creation: Optional[bool] = Field(
        None,
        description='Whether the DAG is paused upon creation.\n\n*New in version 2.3.0*\n',
    )
    last_parsed: Optional[datetime] = Field(
        None,
        description='The last time the DAG was parsed.\n\n*New in version 2.3.0*\n',
    )
    orientation: Optional[str] = None
    params: Optional[Dict[str, Any]] = Field(
        None, description='User-specified DAG params.\n\n*New in version 2.0.1*\n'
    )
    render_template_as_native_obj: Optional[bool] = Field(
        None,
        description='Whether to render templates as native Python objects.\n\n*New in version 2.3.0*\n',
    )
    start_date: Optional[datetime] = Field(
        None,
        description="The DAG's start date.\n\n*Changed in version 2.0.1*&#58; Field becomes nullable.\n",
    )
    template_search_path: Optional[List[str]] = Field(
        None, description='The template search path.\n\n*New in version 2.3.0*\n'
    )
    timezone: Optional[Timezone] = None


class Task(BaseModel):
    class_ref: Optional[ClassReference] = None
    depends_on_past: Optional[bool] = None
    downstream_task_ids: Optional[List[str]] = None
    end_date: Optional[datetime] = None
    execution_timeout: Optional[TimeDelta] = None
    extra_links: Optional[List[ExtraLink1]] = None
    is_mapped: Optional[bool] = None
    owner: Optional[str] = None
    pool: Optional[str] = None
    pool_slots: Optional[float] = None
    priority_weight: Optional[float] = None
    queue: Optional[str] = None
    retries: Optional[float] = None
    retry_delay: Optional[TimeDelta] = None
    retry_exponential_backoff: Optional[bool] = None
    start_date: Optional[datetime] = None
    sub_dag: Optional[DAG] = None
    task_id: Optional[str] = None
    template_fields: Optional[List[str]] = None
    trigger_rule: Optional[TriggerRule] = None
    ui_color: Optional[Color] = None
    ui_fgcolor: Optional[Color] = None
    wait_for_downstream: Optional[bool] = None
    weight_rule: Optional[WeightRule] = None


class TaskCollection(BaseModel):
    tasks: Optional[List[Task]] = None
